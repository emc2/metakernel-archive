#ifndef DATA_STRUCTURES_H
#define DATA_STRUCTURES_H

/* Copyright (c) 2003 Eric McCorkle.  All rights reserved.
 *
 * Permission is granted to use or distribute in source or
 * binary with the following conditions:
 *
 * 1) Eric McCorkle, henceforth referred to as "Author" retains
 * authorship and ownership of this code, any statement,
 * contract, condition, or agreement to the contrary, whether
 * implicit or explicit notwithstanding.
 *
 * 2) All express or implied warranties are disclaimed, including
 * but not limited to, all implied warranties of merchantability
 * and fitness for a particular purpose.  In no event may the
 * Author be held liable for any damages, whether direct,
 * indirect, incidental, special, exemplary, or consequential,
 * of any kind (including, but not limited to procurement of
 * substitute goods or services, loss of data, loss of use,
 * loss of profits, or business interruption) however caused
 * and on any theory of liability, whether in contract, strict
 * liability, or tort (including negilgence or otherwise) arising
 * in any way out of the use of this software, even if advised of
 * the possibility of such damage.
 *
 * 3) Any product using the code in this file must contain an
 * unaltered copy of this statement wherever the code is used,
 * and credit must be given to the Author as the author of
 * the specific part or parts of the product using the code,
 * wherever authors are listed.
 *
 * 4) The code may not be modified in any way.  It may only
 * be used or distributed if it matches the current version
 * exactly.  The current version may be changed at any
 * time without notification.
 *
 * 5) No product may be derived from this work without explicit
 * permission from the Author, and observance of any
 * conditions set forth in such an agreement.  Such permission
 * is not granted by this statement.
 *
 * 6) The Author reserves the right to explicitly deny any
 * individual, corportation, association, or group the right
 * to use or distribute this code.
 *
 * 7) The Author shall be recognized as the author of any code
 * generated by source code, assembler code, or preprocessor
 * macros or directives, or any other content contained in
 * this code, and of any source or binary code generated from
 * this code by another program.
 *
 * 8) Any comment, text, or any other form of content in
 * this code which conflicts in ny way with this
 * statement is null and void.
 *
 * 9) Usage or distribution of this code constitutes agreement
 * in full to the terms given by this statement.
 *
 * 10) Failure to abide by these terms results in an automatic
 * suspension of the right to use, as detailed by condition 6,
 * for an indefinite period of time.
 *
 */

/* Version 1.3 */

/* this file contains macros to auto-generate data structures */

/* Red-black trees are an extremely powerful self-balancing binary
 * tree variant.  They tolerate a maximum depth of 2 * log(n+1).  In
 * practice, however, they are almost always nearly perfectly
 * balanced, resulting in search times of O(log(n+1)).
 *
 * This structure is best used when it is necessary to lookup the
 * closest available element to a given input (find the number closest
 * to n), or when it is convenient to be able to generate a sorted
 * list in O(n) time.  For pinpoint lookups, use a hash table.
 *
 * prefix is the name for the functions that are generated
 * type is the data type of a node
 * comp is a comparison of the node type, evaluating to -1 for 
 *      less than, 0 for equal, and 1 for greater than
 * null represents a null node
 * left gets the left node
 * right gets the right node
 * up gets the parent node
 * color gets the color flags
 *
 * The following functions are also generated:
 *
 * void <prefix>_tree_insert(<prefix>_tree_node** tree, <type> data);
 * Inserts data into the tree pointed to by tree.  (Requires a double-
 * pointer in order to do rotations).
 *
 * <type> <prefix>_tree_delete(<prefix>_tree_node** tree, <type> data);
 * Deletes the first node found to be equivalent to data from the tree
 * pointed to by tree.
 *
 * Lookups aren't implemented because a) they are trivial to
 * implement, b) it has been my experience that users typically need
 * specialized lookup functions, c) users may want to implement
 * lookups using some subset of the data contained in <type>.
 *
 * This tree works with unique or non-unique entries.  Identical
 * entries will not be stored in any particular order (aside from
 * being adjacent at all times), nor will any particular selection be
 * applied when removing identical entries.
 */ 


#define RED_BLACK_TREE_HEADERS(prefix, f_prefix, type)\
\
f_prefix void prefix ## _tree_insert(type*, type);\
f_prefix type prefix ## _tree_delete(type*, type);\

#define RED_BLACK_TREE(prefix, f_prefix, type, comp, null,\
		       left, right, up, color)\
\
static const unsigned int prefix ## _COLOR = 0x01;\
/*static const unsigned int prefix ## _RED = 0x00;*/\
static const unsigned int prefix ## _BLACK = 0x01;\
\
\
static inline type prefix ## _uncle_node(type node) {\
\
  return (up(node) == left(up(up(node)))) ?\
    right(up(up(node))) : left(up(up(node)));\
\
}\
\
\
static inline type  prefix ## _brother_node(type node) {\
\
  return (node == left(up(node))) ?\
    right(up(node)) : left(up(node));\
\
}\
\
\
static void prefix ## _s_right_rotate(type* tree) {\
\
  type top;\
  type child;\
  int tmp;\
\
  top = *tree;\
  child = left(*tree);\
\
  /* swap colors */\
  tmp = (color(top) & prefix ## _COLOR);\
  color(top) &= ~ prefix ## _COLOR;\
  color(top) |= (color(child) & prefix ## _COLOR);\
  color(child) &= ~ prefix ## _COLOR;\
  color(child) |= tmp;\
  left(top) = right(child);\
\
  if(null != right(child))\
    up(right(child)) = top;\
\
  up(child) = up(top);\
  right(child) = top;\
  up(top) = child;\
  *tree = child;\
\
}\
\
\
static void prefix ## _s_left_rotate(type* tree) {\
\
  type top;\
  type child;\
  int tmp;\
\
  top = *tree;\
  child = right(*tree);\
\
  /* swap colors */\
  tmp = (color(top) & prefix ## _COLOR);\
  color(top) &= ~ prefix ## _COLOR;\
  color(top) = (color(child) & prefix ## _COLOR);\
  color(child) &= ~ prefix ## _COLOR;\
  color(child) |= tmp;\
  right(top) = left(child);\
\
  if(null != left(child))\
    up(left(child)) = top;\
\
  up(child) = up(top);\
  left(child) = top;\
  up(top) = child;\
  *tree = child;\
\
}\
\
\
static inline void prefix ## _d_right_rotate(type* tree) {\
\
  prefix ## _s_left_rotate(&left(*tree));\
  prefix ## _s_right_rotate(tree);\
\
}\
\
\
static inline void prefix ## _d_left_rotate(type* tree) {\
\
  prefix ## _s_right_rotate(&right(*tree));\
  prefix ## _s_left_rotate(tree);\
\
}\
\
\
f_prefix void prefix ## _tree_insert(type* tree, type in) {\
\
  type curr;\
  type last;\
  int child_direction;\
\
  color(in) &= ~ prefix ## _COLOR;\
  curr = *tree;\
\
  if(null != *tree) {\
\
    do {\
\
      last = curr;\
\
      if(comp(curr, in) > 0)\
        curr = left(curr);\
\
      else\
        curr = right(curr);\
\
    } while(null != curr);\
\
    up(in) = last;\
    right(in) = null;\
    left(in) = null;\
\
    if(comp(in, last) < 0)\
      left(last) = in;\
\
    else\
      right(last) = in;\
\
    curr = in;\
\
    while(up(curr) != null) {\
\
      /* easy end condition, also takes care of if\
       * case parent is root since root cannot be red\
       */\
      if(color(up(curr)) & prefix ## _COLOR)\
        break;\
\
      /* transfer heat up the tree */\
      else if(!(null != prefix ## _uncle_node(curr) ?\
                color(prefix ## _uncle_node(curr)) &\
	        prefix ## _COLOR : prefix ## _BLACK)) {\
\
        color(left(up(up(curr)))) |= prefix ## _BLACK;\
        color(right(up(up(curr)))) |= prefix ## _BLACK;\
\
        if(null != up(up(up(curr))))\
          color(up(up(curr))) &= ~ prefix ## _COLOR;\
\
        curr = up(up(curr));\
\
      }\
\
      /* rotation cases */\
      else {\
\
        /* right */\
        if(up(curr) == left(up(up(curr)))) {\
\
          if(curr == left(up(curr))) {\
\
            curr = up(up(curr));\
\
            if(null != up(curr))\
              child_direction = (curr == left(up(curr)));\
\
            prefix ## _s_right_rotate(&curr);\
\
          }\
\
          else {\
\
            curr = up(up(curr));\
\
            if(null != up(curr))\
              child_direction = (curr == left(up(curr)));\
\
            prefix ## _d_right_rotate(&curr);\
\
          }\
\
        }\
\
        /* left */\
        else {\
\
          if(curr == right(up(curr))) {\
\
            curr = up(up(curr));\
\
            if(null != up(curr))\
              child_direction = (curr == left(up(curr)));\
\
            prefix ## _s_left_rotate(&curr);\
\
          }\
\
          else {\
\
            curr = up(up(curr));\
\
            if(null != up(curr))\
              child_direction = (curr == left(up(curr)));\
\
            prefix ## _d_left_rotate(&curr);\
\
          }\
\
        }\
\
        if(null != up(curr)) {\
\
          if(child_direction)\
            left(up(curr)) = curr;\
\
          else\
            right(up(curr)) = curr;\
\
        }\
\
        break;\
\
      }\
\
    }\
\
    while(NULL != up(curr))\
      curr = up(curr);\
\
    *tree = curr;\
\
  }\
\
  else {\
\
    up(in) = null;\
    right(in) = null;\
    left(in) = null;\
    color(in) |= prefix ## _BLACK;\
    *tree = in;\
\
  }\
\
}\
\
\
f_prefix type prefix ## _tree_delete(type* tree, type in) {\
\
  type node_ptr;\
  type fix_ptr;\
  type replacement;\
  type target;\
  int direction;\
  int run_fixer;\
  int child_direction;\
\
  target = *tree;\
\
  /* find the target */\
  while(null != target) {\
\
    if(0 == comp(target, in))\
      break;\
\
    else if(-1 == comp(target, in))\
      target = left(target);\
\
    else\
      target = right(target);\
\
  }\
\
  /* if no such node exists, return a failure */\
  if(null != target) {\
\
    /* easy end condition of the first half */\
    if(null == left(target) && null == right(target)) {\
\
      if(null != up(target)) {\
\
        fix_ptr = target;\
        run_fixer = (color(target) & prefix ## _COLOR);\
        replacement = null;\
\
      }\
\
      else {\
\
        *tree = null;\
\
        return target;\
\
      }\
\
    }\
\
    else {\
\
      /* get the replacement */\
      direction = (left(target) == null);\
      node_ptr = direction ? right(target) : left(target);\
\
      while(null != (direction ?\
                     left(node_ptr) : right(node_ptr)))\
        node_ptr = direction ? left(node_ptr) : right(node_ptr);\
\
      /* set up info for the fixer */\
      run_fixer = (color(node_ptr) & prefix ## _COLOR);\
      fix_ptr = node_ptr;\
      replacement = fix_ptr;\
\
    }\
\
    /* run the fixer */\
    while(run_fixer && up(fix_ptr) != null) {\
\
      /* basic end condition */\
      if(!(color(fix_ptr) & prefix ## _COLOR)) {\
\
        color(fix_ptr) |= prefix ## _BLACK;\
        break;\
\
      }\
\
      node_ptr = prefix ## _brother_node(fix_ptr);\
\
      /* case 1 */\
      if(!(color(node_ptr) & prefix ## _COLOR)) {\
\
        if(node_ptr == left(up(node_ptr))) {\
\
          node_ptr = up(node_ptr);\
\
          if(null != up(node_ptr))\
            child_direction = (node_ptr == left(up(node_ptr)));\
\
          prefix ## _s_right_rotate(&node_ptr);\
\
        }\
\
        else {\
\
          node_ptr = up(node_ptr);\
\
          if(null != up(node_ptr))\
            child_direction = (node_ptr == left(up(node_ptr)));\
\
          prefix ## _s_left_rotate(&node_ptr);\
\
        }\
\
        if(NULL != up(node_ptr)) {\
\
          if(child_direction)\
            left(up(node_ptr)) = node_ptr;\
\
          else\
            right(up(node_ptr)) = node_ptr;\
\
        }\
        /* continue on through the next loop... */\
\
      }\
\
      /* case 2 */\
      else if((left(node_ptr) == null ?\
               prefix ## _BLACK : color(left(node_ptr)) &\
	       prefix ## _COLOR) &&\
              (right(node_ptr) == null ?\
               prefix ## _BLACK : color(right(node_ptr)) &\
	       prefix ## _COLOR)) {\
\
        color(node_ptr) &= ~ prefix ## _COLOR;\
        fix_ptr = up(fix_ptr);\
\
      }\
\
      /* case 3\
       *\
       * the conditionals are complicated...  I'm sorry\
       * essentially, if the brother's inner child is red\
       * and the outer child is black\
       */\
      else if((node_ptr == left(up(node_ptr))) ?\
              ((left(node_ptr) == null ?\
                prefix ## _BLACK : color(left(node_ptr)) &\
		prefix ## _COLOR) &&\
               !(right(node_ptr) == null ?\
                 prefix ## _BLACK : color(right(node_ptr)) &\
	         prefix ## _COLOR)) :\
              ((right(node_ptr) == null ?\
                prefix ## _BLACK : color(right(node_ptr)) &\
		prefix ## _COLOR) &&\
               !(left(node_ptr) == null ?\
                 prefix ## _BLACK : color(left(node_ptr)) &\
	         prefix ## _COLOR))) {\
\
        if(node_ptr == left(up(node_ptr))) {\
\
          prefix ## _s_left_rotate(&node_ptr);\
          left(up(node_ptr)) = node_ptr;\
\
        }\
\
        else {\
\
          prefix ## _s_right_rotate(&node_ptr);\
          right(up(node_ptr)) = node_ptr;\
\
        }\
\
        /* run the next iteration */\
\
      }\
\
      /* case 4 */\
      else {\
\
        if(node_ptr == left(up(node_ptr))) {\
\
          node_ptr = up(node_ptr);\
\
          if(null != up(node_ptr))\
            child_direction = (node_ptr == left(up(node_ptr)));\
\
          prefix ## _s_right_rotate(&node_ptr);\
\
        }\
\
        else {\
\
          node_ptr = up(node_ptr);\
\
          if(null != up(node_ptr))\
            child_direction = (node_ptr == left(up(node_ptr)));\
\
          prefix ## _s_left_rotate(&node_ptr);\
\
        }\
\
        if(null != up(node_ptr)) {\
\
          if(child_direction)\
            left(up(node_ptr)) = node_ptr;\
\
          else\
            right(up(node_ptr)) = node_ptr;\
\
        }\
\
        node_ptr = prefix ## _brother_node(up(fix_ptr));\
        color(node_ptr) |= prefix ## _BLACK;\
\
        /* this stops the loop */\
        break;\
\
      }\
\
    }\
\
    if(null != replacement) {\
\
      /* start moving the node into position */\
      color(replacement) &= ~ prefix ## _COLOR;\
      color(replacement) |= (target->flags & prefix ## _COLOR);\
\
      /* remove it from the old position */\
      if(left(target) != replacement &&\
         right(target) != replacement) {\
\
        if(direction) {\
\
          if(null != up(replacement))\
            left(up(replacement)) = right(replacement);\
\
          if(null != right(replacement))\
            up(right(replacement)) = up(replacement);\
\
        }\
\
        else {\
\
          if(null != up(replacement))\
            right(up(replacement)) = left(replacement);\
\
          if(null != left(replacement))\
            up(left(replacement)) = up(replacement);\
\
        }\
\
      }\
\
      else {\
\
        if(right(target) == replacement)\
          right(target) = right(replacement);\
\
        else\
          left(target) = left(replacement);\
\
      }\
\
      /* install it into the new position */\
      if(null != left(target))\
        up(left(target)) = replacement;\
\
      if(null != right(target))\
        up(right(target)) = replacement;\
\
      if(null != up(target)) {\
\
        if(target == left(up(target)))\
          left(up(target)) = replacement;\
\
        else\
          right(up(target)) = replacement;\
\
      }\
\
      /* set up its references */\
      up(replacement) = up(target);\
\
      if(right(target) != replacement)\
        right(replacement) = right(target);\
\
      else\
        right(replacement) = null;\
\
      if(left(target) != replacement)\
        left(replacement) = left(target);\
\
      else\
        left(replacement) = null;\
\
    }\
\
    else if(target == left(up(target))) {\
\
      replacement = up(target);\
      left(up(target)) = null;\
\
    }\
\
    else {\
\
      replacement = up(target);\
      right(up(target)) = null;\
\
    }\
\
    /* get back to the top */\
    while(null != up(replacement))\
      replacement = up(replacement);\
\
    *tree = replacement;\
\
    return target;\
\
  }\
\
  else\
    return null;\
\
}


/* Hash tables are a classic data structure which excel at pinpoint
 * associative indexing.  When used properly, they have lookup times
 * approaching O(1), making them the most effective data structure for
 * this application.
 *
 * This structure is best used when it is necessary to lookup items
 * exactly, with no need to relate to other items, and no need to
 * generate output in any particular format.
 *
 * prefix is the name to give the functions
 * type is the node's data type
 * unique_type is the type of the unique key
 * next gets the next node in a list
 * null is a value of type <type> representing NULL
 * unique_eq compares two items of type <unique_type>, and evaluates
 *           exactly as == does
 * unique_id takes in an node of type <type> and produces an id
 *           of type unique_type.
 * hash_func takes in an item of type <unique_type> and produces an
 *           unsigned integer
 * alloc_func is the allocator to use
 *
 * The STAT_HASH_TABLE variant produces statically size tables.  It
 * takes in size in place of alloc_func.
 *
 * There are several requirements for the inputs.  hash_func MUST be
 * well-defined, meaning that it ALWAYS produces the same output for a
 * given input.  It does not need to be one-to-one, however (the same
 * output may be generated for many different inputs), though it is
 * best if it rarely generates the same output for two given inputs.
 * It should generate integers in the largest possible range.
 *
 * unique_func does not need to be well-defined, although it must
 * always generate a unique value (it is only important that the value
 * generated is not currently in use, and will not be generated again
 * as long as it stays in use).  It is best if this value is as random
 * as possible.
 *
 * Another struct named <prefix>_hash_table is generated.  This
 * contains the size (called size) and an array of <prefix>_hash_nodes
 * (called table).
 *
 * In addition, the following functions are generated:
 *
 * <prefix>_hash_table* <prefix>_hash_table_init(unsigned int size);
 * creates a hash table of size size
 *
 * <unique_type> <prefix>_hash_table_insert(<prefix>_hash_table* table,
 *                                          <type> data);
 * inserts data into table, returns the unique key to which data is bound
 *
 * <type> <prefix>_hash_table_lookup(<prefix>_hash_table* table,
 *                                   <unique_type> key);
 * looks up the object bound to key in table
 *
 * <type> <prefix>_hash_table_delete(<prefix>_hash_table* table,
 *                                   <unique_type> key);
 * removes the object bound to key from table, returns that object
 *
 * note: for the performance of the hash table to be good, the size
 * must be large.  Also, the size should be a prime number, if
 * possible, and CERTAINLY must not be related to any numerical
 * anomalies of the input (ie. a hash table that uses memory addresses
 * (most of which are divisible by 4 or 8) as its keys should not have
 * a size that is a multiple of 4 or 8, or else 3/4 (or 7/8) of the
 * slots in the table will never be used).
 */

#define HASH_TABLE_HEADERS(prefix, f_prefix, type, unique_type)\
\
typedef struct {\
\
  unsigned int size;\
  type table[];\
\
} prefix ## _hash_table;\
\
\
f_prefix prefix ## _hash_table* prefix ## _hash_table_init(unsigned int);\
f_prefix unique_type prefix ## _hash_table_insert(prefix ## _hash_table*, type);\
f_prefix type prefix ## _hash_table_lookup(prefix ## _hash_table*, unique_type);\
f_prefix type prefix ## _hash_table_delete(prefix ## _hash_table*, unique_type);

#define STAT_HASH_TABLE_HEADERS(prefix, f_prefix, type, unique_type, size)\
\
typedef type prefix ## _hash_table [size];\
\
f_prefix unique_type prefix ## _hash_table_insert(prefix ## _hash_table, type);\
f_prefix type prefix ## _hash_table_lookup(prefix ## _hash_table, unique_type);\
f_prefix type prefix ## _hash_table_delete(prefix ## _hash_table, unique_type);


/* this is a shortcut that uses malloc and free */
#define STD_HASH_TABLE(prefix, type, unique_type, next, null,\
		       unique_eq, unique_id, hash_func)\
HASH_TABLE(prefix, type, unique_type, next, null, unique_eq,\
	   unique_id, hash_func, malloc);


#define HASH_TABLE(prefix, type, unique_type, next, null,\
		   unique_eq, unique_id, hash_func, alloc_func)\
\
\
f_prefix prefix ## _hash_table* prefix ## _hash_table_init(unsigned int size) {\
\
  prefix ## _hash_table* out;\
  int i;\
\
  out = alloc_func(sizeof(prefix ## _hash_table) + (size * sizeof(type)));\
  out->size = size;\
\
  for(i = 0; i < size; i++)\
    out->table[i] = null;\
\
  return out;\
\
}\
\
\
f_prefix unique_type prefix ## _hash_table_insert(prefix ## _hash_table* table,\
					          type in) {\
\
  unique_type key;\
  unsigned int index;\
\
  key = unique_id(in);\
  index = hash_func(key) % table->size;\
  next(in) = table->table[index];\
  table->table[index] = in;\
\
  return key;\
}\
\
\
f_prefix type prefix ## _hash_table_lookup(prefix ## _hash_table* table,\
		  		           unique_type key) {\
\
  unsigned int index;\
  type curr;\
\
  index = hash_func(key) % table->size;\
  curr = table->table[index];\
\
  while(null != curr) {\
\
    if(unique_eq(unique_id(curr), key))\
      return curr;\
\
    curr = next(curr);\
\
  }\
\
  return null;\
\
}\
\
\
f_prefix type prefix ## _hash_table_delete(prefix ## _hash_table* table,\
		 		           unique_type key) {\
\
  unsigned int index;\
  type curr;\
  type last;\
\
  index = hash_func(key) % table->size;\
  curr = table->table[index];\
\
  if(null == curr)\
    return null;\
\
  if(unique_eq(unique_id(curr), key)) {\
\
    table->table[index] = next(curr);\
\
    return curr;\
\
  }\
\
  last = curr;\
  curr = next(curr);\
\
  while(null != curr) {\
\
    if(unique_eq(unique_id(curr), key)) {\
\
      next(last) = next(curr);\
\
      return curr;\
\
    }\
\
    last = curr;\
    curr = next(curr);\
\
  }\
\
  return null;\
\
}

#define STAT_HASH_TABLE(prefix, f_prefix, type, unique_type, next, null,\
                        unique_eq, unique_id, hash_func, size)\
\
\
f_prefix unique_type prefix ## _hash_table_insert(prefix ## _hash_table table,\
                                         type in) {\
\
  unique_type key;\
  unsigned int index;\
\
  key = unique_id(in);\
  index = hash_func(key) % size;\
  next(in) = table[index];\
  table[index] = in;\
\
  return key;\
}\
\
\
f_prefix type prefix ## _hash_table_lookup(prefix ## _hash_table table,\
                                  unique_type key) {\
\
  unsigned int index;\
  type curr;\
\
  index = hash_func(key) % size;\
  curr = table[index];\
\
  while(null != curr) {\
\
    if(unique_eq(unique_id(curr), key))\
      return curr;\
\
    curr = next(curr);\
\
  }\
\
  return null;\
\
}\
\
\
f_prefix type prefix ## _hash_table_delete(prefix ## _hash_table table,\
                                  unique_type key) {\
\
  unsigned int index;\
  type curr;\
  type last;\
\
  index = hash_func(key) % size;\
  curr = table[index];\
\
  if(null == curr)\
    return null;\
\
  if(unique_eq(unique_id(curr), key)) {\
\
    table[index] = next(curr);\
\
    return curr;\
\
  }\
\
  last = curr;\
  curr = next(curr);\
\
  while(null != curr) {\
\
    if(unique_eq(unique_id(curr), key)) {\
\
      next(last) = next(curr);\
\
      return curr;\
\
    }\
\
    last = curr;\
    curr = next(curr);\
\
  }\
\
  return null;\
\
}



/* Writing a simple linear linked list would be a terrible waste of
 * time, especially since the usage of such a structure is VERY
 * difficult to predict...
 *
 * This linked list is a doubly linked circular list, which is far
 * more convenient for many applications.
 *
 * I only define insert and delete.  Accesses are assumed to be
 * user-defined, as it is too difficult to predict how these will be
 * used.
 *
 * prefix is the name to call the functions
 * type is the data type
 * next gets the next node
 * last gets the last node
 * null is a representation of null
 *
 * A struct called <prefix>_clist_node is created.  Any pointer to this
 * represents a list.
 *
 * The following functions are also generated:
 *
 * <prefix>_clist_node* <prefix>_clist_insert(<prefix>_clist_node* list,
 *                                            type data)
 * creates node containing data, and inserts the node into list such
 * that the node pointed to by list is "pushed" forward one, returns a
 * pointer to the new node
 *
 * <prefix>_clist_node* <prefix>_clist_delete(<prefix>_clist_node* list)
 * removes the node pointed to by list and connects list's next and last
 * nodes, returns a pointer to list's next node
 *
 * NOTE: This data structure is highly robust.  It's structure in
 * memory is independent of which particular node is pointed to as the
 * "start" of the list.  Both functions can be called on any node in
 * the list, regardless of its position.  The functions behave as one
 * would expect them to if the pointer passed in was the first node of
 * the list.
 */

#define CIRCULAR_LIST_HEADERS(prefix, f_prefix, type)\
\
f_prefix type prefix ## _clist_insert(type, type);\
f_prefix type prefix ## _clist_delete(type);

#define CIRCULAR_LIST(prefix, f_prefix, type, next, last, null)\
\
f_prefix type prefix ## _clist_insert(type list, type in) {\
\
  if(null == list) {\
\
    next(in) = in;\
    last(in) = in;\
\
  }\
\
  else {\
\
    next(in) = list;\
    last(in) = last(list);\
    next(last(list)) = in;\
    last(list) = in;\
\
  }\
\
  return in;\
\
}\
\
\
f_prefix type prefix ## _clist_delete(type list) {\
\
  if(null != list)\
    if(list != next(list)) {\
\
      next(last(list)) = next(list);\
      last(next(list)) = last(list);\
\
      return next(list);\
\
    }\
\
  return null;\
\
}


/* Binary heaps are a curious data structure that has the property of
 * being able to quickly prioritize data.  Beyond this, they are not
 * very useful.  They are best used for priority queues when data is
 * not being input in order of priority.  Note: it may be more useful
 * keep the index of each element stored somewhere.  This allows for
 * O(1) lookups, making the data structure far more useful.
 *
 * prefix is the name to call the functions
 * type is the type of data involved
 * key_type is the type of the key
 * data_name is the name to give the heap array
 * comp compares two keys, functioning exactly like strcmp
 * get_key retrieves the key from a data element
 * set_key sets the key in a data element
 * resize policy is how to grow the heap in size
 * failure is what to return in the case of over or underflows
 * update_index updates the recorded index of the element
 * alloc_func is the malloc()-equivalent function to use
 * realloc_func is the realloc()-equivalent function to use
 *
 * A struct called <prefix>_heap is generated.  A pointer to this
 * structure represents a binary heap.
 *
 * The following functions are also generated:
 *
 * <prefix>_heap_init(unsigned int size)
 * creates a binary heap, initializing it to size <size>
 *
 * <prefix>_heap_insert(<prefix>_heap* heap, <type> data)
 * inserts <data> into <heap>
 *
 * <prefix>_heap_head(<prefix>_heap* heap)
 * returns the current min (or max) element
 *
 * <prefix>_heap_delete(<prefix>_heap* heap, unsigned int index)
 * deletes element <index> from the heap
 *
 * <prefix>_heap_set_key(<prefix>_heap* heap, unsigned int index,
 *                       <key_type> key)
 * sets the key of element <index> in <heap> to <key>
 *
 * NOTE: update_index can be a null macro, eliminating the correlation
 */

#define BINARY_HEAP_HEADERS(prefix, f_prefix, type, key_type, data_name)\
typedef struct {\
\
  unsigned int size;\
  unsigned int max;\
  type data_name[];\
\
} prefix ## _heap;\
\
f_prefix prefix ## _heap* prefix ## _heap_init(unsigned int);\
f_prefix void prefix ## _heap_insert(prefix ## _heap*, type);\
f_prefix type prefix ## _heap_head(prefix ## _heap*);\
f_prefix type prefix ## _heap_delete(prefix ## _heap*, unsigned int);\
f_prefix void prefix ## _heap_set_key(prefix ## _heap*, unsigned int, key_type);


#define STD_BINARY_HEAP(prefix, type, key_type, data_name, \
			comp, get_key, set_key, update_index,\
			resize_policy, failure)\
BINARY_HEAP(prefix, type, key_type, data_name, \
	    comp, get_key, set_key, update_index,\
	    resize_policy, failure, malloc, realloc);

#define BINARY_HEAP(prefix, type, data_name, comp, get_key,\
		    set_key, update_index, resize_policy,\
		    failure, alloc_func, realloc_func)\
\
prefix ## _heap* prefix ## _heap_init(unsigned int size) {\
\
  prefix ## _heap* out;\
\
  out = malloc(sizeof(prefix ## _heap) + (sizeof(type) * size));\
  out->size = 0;\
  out->max = size;\
\
  return out;\
\
}\
\
\
f_prefix void prefix ## _heap_insert(prefix ## _heap* heap, type in) {\
\
  int i;\
  int cont = 1;\
\
  if(heap->size >= heap->max) {\
\
    heap->max = resize_policy(heap->max);\
    heap = realloc_func(heap->data_name, sizeof(prefix ## _heap) +\
                        heap->max * sizeof(type));\
\
  }\
\
  i = (++heap->size);\
\
  while(i != 1 && 1 == comp(in, heap->data_name[(i / 2) - 1])) {\
\
    memcpy(heap->data_name + (i - 1),\
	   heap->data_name + ((i / 2) - 1),\
	   sizeof(type));\
    update_index(heap->data_name[i - 1], i);\
    i /= 2;\
\
  }\
\
  while(cont) {\
\
    if(((2 * i) + 1) <= heap->size &&\
       1 == comp(heap->data_name[2 * i],\
		 heap->data_name[i - 1])) {\
\
      if((2 * i) <= heap->size &&\
         1 == comp(heap->data_name[(2 * i) - 1],\
		   heap->data_name[2 * i])) {\
\
        memcpy(heap->data_name + (i - 1),\
	       heap->data_name + ((i * 2) - 1),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
        i *= 2;\
\
      }\
\
      else {\
\
        memcpy(heap->data_name + (i - 1),\
	       heap->data_name + (i * 2),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
        i *= 2;\
        i++;\
\
      }\
\
    }\
\
    else if((2 * i) <= heap->size &&\
	    1 == comp(heap->data_name[(2 * i) - 1],\
		      heap->data_name[i - 1])) {\
\
      if(((2 * i) + 1) <= heap->size &&\
         1 == comp(heap->data_name[2 * i],\
		   heap->data_name[(2 * i) - 1])) {\
\
        memcpy(heap->data_name + (i - 1),\
	       heap->data_name + (i * 2),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
        i *= 2;\
        i++;\
\
      }\
\
      else {\
\
        memcpy(heap->data_name + (i - 1),\
	       heap->data_name + ((i * 2) - 1),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
        i *= 2;\
\
      }\
\
    }\
\
    else\
      cont = 0;\
\
  }\
\
}\
\
\
f_prefix type prefix ## _heap_head(prefix ## _heap* heap) {\
\
  if(0 != heap->size)\
    return heap->data_name[0];\
\
  else\
    return failure;\
\
}\
\
\
f_prefix type prefix ## _heap_delete(prefix ## _heap* heap,\
				     unsigned int index) {\
\
  int i = num;\
  type out;\
  type tmp;\
  int cont = 1;\
\
  if(0 == heap->size || 0 == index || index > heap->size)\
    return failure;\
\
  memcpy(&out, heap->data_name + (index - 1), sizeof(type));\
  heap->size--;\
\
  if(index - 1 == heap->size)\
    return out;\
\
  if(0 != heap->size) {\
\
    memcpy(&tmp, heap->data_name + (heap->size), sizeof(type));\
\
    while(i != 1 && 1 == comp(tmp, heap->data_name[(i / 2) - 1])) {\
\
      memcpy(heap->data_name + (i - 1),\
	     heap->data_name + ((i / 2) - 1),\
	     sizeof(type));\
      update_index(heap->data_name[i - 1], i);\
      i /= 2;\
\
    }\
\
    while(cont) {\
\
      if(((2 * i) + 1) <= heap->size &&\
        1 == comp(heap->data_name[2 * i],\
		  heap->data_name[i - 1])) {\
\
        if((2 * i) <= heap->size &&\
             1 == comp(heap->data_name[(2 * i) - 1],\
		       heap->data_name[2 * i])) {\
\
          memcpy(heap->data_name + (i - 1),\
		 heap->data_name + ((i * 2) - 1),\
		 sizeof(type));\
          update_index(heap->data_name[i - 1], i);\
          i *= 2;\
\
        }\
\
        else {\
\
          memcpy(heap->data_name + (i - 1),\
		 heap->data_name + (i * 2),\
		 sizeof(type));\
          update_index(heap->data_name[i - 1], i);\
          i *= 2;\
          i++;\
\
        }\
\
      }\
\
      else if((2 * i) <= heap->size &&\
            1 == comp(heap->data_name[(2 * i) - 1],\
		      heap->data_name[i - 1])) {\
\
        if(((2 * i) + 1) <= heap->size &&\
           1 == comp(heap->data_name[2 * i],\
		     heap->data_name[(2 * i) - 1])) {\
\
          memcpy(heap->data_name + (i - 1),\
		 heap->data_name + (i * 2),\
		 sizeof(type));\
          update_index(heap->data_name[i - 1], i);\
          i *= 2;\
          i++;\
\
        }\
\
        else {\
\
          memcpy(heap->data_name + (i - 1),\
		 heap->data_name + ((i * 2) - 1),\
		 sizeof(type));\
          update_index(heap->data_name[i - 1], i);\
          i *= 2;\
\
        }\
\
      }\
\
      else\
        cont = 0;\
\
    }\
\
  }\
\
  return out;\
\
}\
\
\
f_prefix void prefix ## _heap_key_set(prefix ## _heap* heap,\
		  	              unsigned int index,\
			              key_type key) {\
\
  int i = index;\
  type tmp;\
  int cont = 1;\
  int direction;\
\
  if(0 == heap->size || 0 == index || index > heap->size)\
    return;\
\
  tmp = heap->data_name[i - 1];\
\
  if(get_key(tmp) == key)\
    return;\
\
  direction = get_key(tmp) < key;\
  set_key(tmp, key);\
\
  if(direction) {\
\
    if(1 == i)\
      return;\
\
    while(i != 1 &&\
	  1 == comp(tmp, heap->data_name[(i / 2) - 1])) {\
\
      memcpy(heap->data_name + (i - 1),\
	     heap->data_name + ((i / 2) - 1),\
	     sizeof(type));\
      update_index(heap->data_name[i - 1], i);\
      i /= 2;\
\
    }\
\
  }\
\
  while(cont) {\
\
    if(((2 * i) + 1) <= heap->size &&\
       1 == comp(heap->data_name[2 * i],\
		 heap->data_name[i - 1])) {\
\
      if((2 * i) <= heap->size &&\
	 1 == comp(heap->data_name[(2 * i) - 1],\
		   heap->data_name[2 * i])) {\
\
	memcpy(heap->data_name + (i - 1),\
	       heap->data_name + ((i * 2) - 1),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
	i *= 2;\
\
      }\
\
      else {\
\
	memcpy(heap->data_name + (i - 1),\
	       heap->data_name + (i * 2),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
	i *= 2;\
	i++;\
\
      }\
\
    }\
\
    else if((2 * i) <= heap->size &&\
            1 == comp(heap->data_name[(2 * i) - 1],\
		      heap->data_name[i - 1])) {\
\
      if(((2 * i) + 1) <= heap->size &&\
	 1 == comp(heap->data_name[2 * i],\
		   heap->data_name[(2 * i) - 1])) {\
\
	memcpy(heap->data_name + (i - 1),\
	       heap->data_name + (i * 2),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
	i *= 2;\
	i++;\
\
      }\
\
      else {\
\
	memcpy(heap->data_name + (i - 1),\
	       heap->data_name + ((i * 2) - 1),\
	       sizeof(type));\
        update_index(heap->data_name[i - 1], i);\
	i *= 2;\
\
      }\
\
    }\
\
    else\
      cont = 0;\
\
  }\
\
  memcpy(heap->data_name + (i - 1), &tmp, sizeof(type));\
  update_index(heap->data_name[i - 1], i);\
\
}

#endif
